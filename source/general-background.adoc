[[general-topics-and-background]]
= General Topics and Background

This chapter is about source code and creating software, which are a necessary
background for an RPM Packager.

[[what-is-source-code]]
== What is Source Code?

**Source code** is human-readable instructions to the computer, which describe
how to perform a computation. Source code is expressed using a
https://en.wikipedia.org/wiki/Programming_language[programming language].

This tutorial features three versions of the ``Hello World`` program, each
written in a different programming language. Programs written in these three
different languages are packaged differently, and cover three major use cases of
an RPM packager.

NOTE: There are thousands of programming languages. This document features only
three of them, but they are enough for a conceptual overview.

``Hello World`` written in https://www.gnu.org/software/bash/[bash]:

``bello``

[source,bash]
----
#!/bin/bash

printf "Hello World\n"

----

``Hello World`` written in https://www.python.org/[Python]:

``pello.py``

[source,python]
----
#!/usr/bin/env python

print("Hello World")

----

``Hello World`` written in https://en.wikipedia.org/wiki/C_%28programming_language%29[C]:

``cello.c``

[source,c]
----
#include <stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}

----

The purpose of every one of the three programs is to output ``Hello World`` on
the command line.

NOTE: Knowing how to program is not necessary for a software packager, but is
helpful.

[[how-programs-are-made]]
== How Programs Are Made

There are many methods by which human-readable source code becomes machine code
- instructions the computer follows to actually execute the program. However,
all methods can be reduced to these two:

// FIXME MAYBE SPLIT NUMBER 2 IN TWO. IF DO, ALSO SPLIT FOLLOWING SECTIONS
1. The program is natively compiled.
2. The program is interpreted: by raw interpreting or through byte compiling.

[[natively-compiled-code]]
=== Natively Compiled Code

**Natively compiled** software is software written in a programming language
that compiles to machine code, with a resulting binary executable file. Such
software can be run stand-alone.

RPM packages built this way are
https://en.wikipedia.org/wiki/Microarchitecture[architecture]-specific. This
means that if you compile such software on a computer that uses a 64-bit
(x86_64) AMD or Intel processor, it will not execute on a 32-bit (x86) AMD or
Intel processor. The resulting package will have architecture specified in its
name.

[[interpreted-code]]
=== Interpreted Code

Some programming languages, such as https://www.gnu.org/software/bash/[bash] or
https://www.python.org/[Python], do not compile to machine code. Instead, their
programs' source code is executed step by step, without prior transformations,
by a https://en.wikipedia.org/wiki/Interpreter_%28computing%29[Language
Interpreter] or a Language Virtual Machine.

There are two types of interpreted languages: byte-compiled and raw-interpreted.
The program build process for these two types is different.

Raw-interpreted language programs do not need to be compiled at all, they are
directly executed by the interpreter.

Byte-compiled languages need to be compiled into byte code, which is then
executed by the language virtual machine.

This difference reflects on the packaging procedure. Some languages give a
choice: they can be raw-interpreted or byte-compiled.

Software written entirely in interpreted programming languages is not
https://en.wikipedia.org/wiki/Microarchitecture[architecture]-specific. Hence,
the resulting RPM Package will have string ``noarch`` in its name.

[[building-software-from-source]]
== Building Software from Source

This section explains building software from its source code.

* For software written in compiled languages, the source code goes through a
**build** process, producing machine code. This process, commonly called
**compiling** or **translating**, varies for different languages. The resulting
built software can be **run** or "**executed**", which makes computer perform
the task specified by the programmer.
* For software written in raw interpreted languages, the source code is not built,
but executed directly.
* For software written in byte-compiled interpreted languages, the source code is
compiled into byte code, which is then executed by the language virtual machine.

NOTE: Software written in different programming languages varies greatly. This
guide does not cover all the possibilities. However, it provides a starting
guideline.

[[natively-compiled-code-building-software-from-source]]
=== Natively Compiled Code

In this example, you will build the ``cello.c`` program written in the
https://en.wikipedia.org/wiki/C_%28programming_language%29[C] language into an
executable.

``cello.c``

[source,c]
----
#include <stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}

----

[[manual-building]]
==== Manual Building

Invoke the https://en.wikipedia.org/wiki/C_%28programming_language%29[C] compiler from the GNU
Compiler Collection (https://gcc.gnu.org/[GCC]) to compile the source code into binary:

[source,bash]
----
gcc -o cello cello.c

----

Execute the resulting output binary ``cello``.

[source,bash]
----
$ ./cello
Hello World

----

That is all. You have built and ran natively compiled software from source code.

==== Automated Building

Instead of building the source code manually, you can automate the building.
This is a common practice used by large-scale software. Automating building is
done by creating a ``Makefile`` and then running the
http://www.gnu.org/software/make/[GNU ``make``] utility.

To set up automated building, create a file named ``Makefile`` in the same
directory as ``cello.c``:

``Makefile``

[source,makefile]
----
cello:
        gcc -o cello cello.c

clean:
        rm cello

----

Now to build the software, simply run ``make``:

[source,bash]
----
$ make
make: 'cello' is up to date.

----

Since there is already a build present, ``make clean`` it and run ``make`` again:

[source,bash]
----
$ make clean
rm cello

$ make
gcc -o cello cello.c

----

Again, trying to build after another build would do nothing:

[source,bash]
----
$ make
make: 'cello' is up to date.

----

Finally, execute the program:

[source,bash]
----
$ ./cello
Hello World

----

You have now compiled a program both manually and using a build tool.

[[interpreted-code-building-software-from-source]]
=== Interpreted Code

The next two examples showcase byte-compiling a program written in
https://www.python.org/[Python] and raw-interpreting a program written in
https://www.gnu.org/software/bash/[bash].

[NOTE]
====
In the two examples below, the ``#!`` line at the top of the file is known as a
https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang] and is not part of the
programming language source code.

The https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang] enables using a
text file as an executable: the system program loader parses the line containing
the *shebang* to get a path to the binary executable, which is then used as the
programming language interpreter.
====

[[byte-compiled-code]]
==== Byte-Compiled Code

In this example, you will compile the ``pello.py`` program written in Python
into byte code, which is then executed by the Python language virtual machine.
Python source code can also be raw-interpreted, but the byte-compiled version is
faster. Hence, RPM Packagers prefer to package the byte-compiled version for
distribution to end users.

``pello.py``

[source,python]
----
#!/usr/bin/env python

print("Hello World")

----

Procedure for byte-compiling programs is different for different languages. It
depends on the language, the language's virtual machine, and the tools and
processes used with that language.

NOTE: https://www.python.org/[Python] is often byte-compiled, but not in the way
described here. The following procedure aims not to conform to the community
standards, but to be simple. For real-world Python guidelines, see
https://docs.python.org/2/library/distribution.html[Software Packaging and
Distribution].

Byte-compile ``pello.py``:

[source,bash]
----
$ python -m compileall pello.py

$ file pello.pyc
pello.pyc: python 2.7 byte-compiled

----

Execute the byte code in ``pello.pyc``:

[source,bash]
----
$ python pello.pyc
Hello World

----

[[raw-interpreted]]
==== Raw Interpreted Code

In this example, you will raw-interpret the ``bello`` program written in the
https://www.gnu.org/software/bash/[bash] shell built-in language.

``bello``

[source,bash]
----
#!/bin/bash

printf "Hello World\n"

----

Programs written in shell scripting languages, like _bash_, are raw-interpreted.
Hence, you only need to make the file with source code executable and run it:

[source,bash]
----
$ chmod +x bello
$ ./bello
Hello World

----

[[patching-software]]
== Patching Software

A **patch** is source code that updates other source code. It is formatted as a
__diff__, because it represents what is different between two versions of text.
A __diff__ is created using the ``diff`` utility, which is then applied to the
source code using the http://savannah.gnu.org/projects/patch/[patch] utility.

NOTE: Software developers often use Version Control Systems such as
https://git-scm.com/[git] to manage their code base. Such tools provide their
own methods of creating diffs or patching software.

In the following example, we create a patch from the originial source code using
``diff`` and then apply it using ``patch``. Patching is used in a later section
when creating an RPM, <<rpm-guide.adoc#working-with-spec-files>>.

How is patching related to RPM packaging? In packaging, instead of simply
modifying the original source code, we keep it, and use patches on it.

To create a patch for ``cello.c``:

. Preserve the original source code:
+
[source,bash]
----
$ cp cello.c cello.c.orig

----
+
This is a common way to preserve the original source code file.
+
. Change ``cello.c``:
+
[source,c]
----
#include <stdio.h>

int main(void) {
    printf("Hello World from my very first patch!\n");
    return 0;
}

----
+
. Generate a patch using the ``diff`` utility:
+
NOTE: We use several common arguments for the ``diff`` utility. For more
information on them, see the ``diff`` manual page.
+
[source,diff]
----
$ diff -Naur cello.c.orig cello.c
--- cello.c.orig        2016-05-26 17:21:30.478523360 -0500
+++ cello.c     2016-05-27 14:53:20.668588245 -0500
@@ -1,6 +1,6 @@
 #include<stdio.h>

 int main(void){
-    printf("Hello World!\n");
+    printf("Hello World from my very first patch!\n");
     return 1;
 }
\ No newline at end of file

----
+
Lines starting with a ``-`` are removed from the original source code and
replaced with the lines that start with ``+``.
+
. Save the patch to a file:
+
[source,bash]
----
$ diff -Naur cello.c.orig cello.c > cello-output-first-patch.patch

----
+
. Restore the original ``cello.c``:
+
[source,bash]
----
$ cp cello.c.orig cello.c

----
+
We retain the original ``cello.c``, because when an RPM is built, the original
file is used, not a modified one. For more information, see
<<rpm-guide.adoc#working-with-spec-files>>.

To patch ``cello.c`` using ``cello-output-first-patch.patch``, redirect the
patch file to the ``patch`` command:

[source,bash]
----
$ patch < cello-output-first-patch.patch
patching file cello.c

----

The contents of ``cello.c`` now reflect the patch:

[source,bash]
----
$ cat cello.c
#include<stdio.h>

int main(void){
    printf("Hello World from my very first patch!\n");
    return 1;
}

----

To build and run the patched ``cello.c``:

[source,bash]
----
$ make clean
rm cello

$ make
gcc -o cello cello.c

$ ./cello
Hello World from my very first patch!

----

You have created a patch, patched a program, built the patched program, and run
it.

[[installing-arbitrary-artifacts]]
== Installing Arbitrary Artifacts

One of the many really nice things about https://en.wikipedia.org/wiki/Linux[Linux] systems is the https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Filesystem
Hierarchy Standard] (FHS) which defines areas of the filesystem in which things
should be placed. As a RPM Packager this is extremely useful because we will
always know where to place things that come from our source code.

This section references the concept of an **Arbitrary Artifact** which in this
context is anything you can imagine that is a file that you want to install
somewhere on the system within the FHS. It could be a simple script,
a pre-existing binary, the binary output of source code that you have created as
a side effect of a build process, or anything else you can think up. We discuss
it in such a vague vocabulary in order to demonstrate that the system nor RPM
care what the __Artifact__ in question is. To both RPM and the system, it is just
a file that needs to exist in a pre-determined place. The permissions and the
type of file it is makes it special to the system but that is for us as a RPM
Packager to decide.

For example, once we have built our software we can then place it on the system
somewhere that will end up in the system https://en.wikipedia.org/wiki/PATH_%28variable%29[$PATH] so that they can be found and
executed easily by users, developers, and sysadmins alike. We will explore two
ways to accomplish this as they each are quite popular approaches used by RPM
Packagers.

[[install-command]]
=== install command

When placing arbitrary artifacts onto the system without build automation
tooling such as http://www.gnu.org/software/make/[GNU make] or because it is a simple script and such tooling
would be seen as unnecessary overhead, it is a very common practice to use the
``install`` command (provided to the system by http://www.gnu.org/software/coreutils/coreutils.html[coreutils]) to place the
artifact in a correct location on the filesystem based on where it should exist
in the FHS along with appropriate permissions on the target file or directory.

The example below is going to use the ``bello`` file that we had previously
created as the arbitrary artifact subject to our installation method. Note that
you will either need http://www.sudo.ws/[sudo] permissions or run this command as root excluding
the ``sudo`` portion of the command.

[source,bash]
----
$ sudo install -m 0755 bello /usr/bin/bello

----

As this point, we can execute ``bello`` from our shell no matter what our
current working directory is because it has been installed into our https://en.wikipedia.org/wiki/PATH_%28variable%29[$PATH].

[source,bash]
----
$ cd ~/

$ bello
Hello World

----

[[make-install]]
=== make install

A very popular mechanism by which you will install software from source after
it’s built is by using a command called ``make install`` and in order to do that
we need to enhance the ``Makefile`` we created previously just a little bit.

NOTE: The creation of ``Makefile`` is normally done by the developer who writes
the original source code of the software in question and as a RPM Packager
this is not generally something you will need to do. This is purely an
exercise for background knowledge and we will expand upon this as it relates
to RPM Packaging later.

Open the ``Makefile`` file up in your favorite text editor and make the
appropriate edits needed so that it ends up looking exactly as the following.

NOTE: The use of https://www.gnu.org/software/make/manual/html_node/DESTDIR.html[$(DESTDIR)] is a http://www.gnu.org/software/make/[GNU make] built-in and is commonly used to
install into alternative destination directories.

``Makefile``

[source,makefile]
----
cello:
        gcc -o cello cello.c

clean:
        rm cello

install:
        mkdir -p $(DESTDIR)/usr/bin
        install -m 0755 cello $(DESTDIR)/usr/bin/cello

----

Now we are able to use the make file to both build and install the software from
source. Note that for the installation portion, like before when we ran the raw
``install`` command, you will need either http://www.sudo.ws/[sudo] permissions or be the ``root``
user and omit the ``sudo`` portion of the command.

The following will build and install the simple ``cello.c`` program that we had
written previously.

[source,bash]
----
$ make
gcc -o cello cello.c

$ sudo make install
install -m 0755 cello /usr/bin/cello

----

Just as in the previous example, we can now execute ``cello`` from our shell no
matter what our current working directory is because it has been installed into
our https://en.wikipedia.org/wiki/PATH_%28variable%29[$PATH].

[source,bash]
----
$ cd ~/

$ cello
Hello World

----

Congratulations, you have now installed a build artifact into it’s proper
location on the system!

[[prepping-our-example-upstream-source-code]]
== Prepping our example upstream source code

NOTE: If you’re familiar with how upstream software is distributed and would like
to skip this, please feel free to https://github.com/redhat-developer/rpm-packaging-guide/tree/master/example-code[download the example source code] for
our fake upstream projects skip this section. However if you are curious how
the examples are created please feel free to read along.

Now that we have our RPM Packaging Workspace setup, we should create simulated
upstream compressed archives of the example programs we have made. We will once
again list them here just in case a previous section was skipped.

NOTE: What we are about to do here in this section is not normally something a RPM
Packager has to do, this is normally what happens from an upstream software
project, product, or developer who actually releases the software as source
code. This is simply to setup the RPM Build example space and give some
insight into where everything actually comes from.

We will also assume https://www.gnu.org/licenses/quick-guide-gplv3.html[GPLv3] as the https://en.wikipedia.org/wiki/Software_license[Software License] for all of these
simulated upstream software releases. As such, we will need a ``LICENSE`` file
included with each source code release. We include this in our simulated
upstream software release because encounters with a https://en.wikipedia.org/wiki/Software_license[Software License] when
packaging RPMs is a very common occurrence for a RPM Packager and we should know
how to properly handle them.

NOTE: The method used below to create the ``LICENSE`` file is known as a https://en.wikipedia.org/wiki/Here_document[here
document].

Let us go ahead and make a ``LICENSE`` file that can be included in the source
code “release” for each example.

[source,bash]
----
$ cat > /tmp/LICENSE <<EOF
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
EOF

----

Each implementation of the ``Hello World`` example script will be created into a
https://www.gnu.org/software/gzip/[gzip] compressed tarball which will be used to simulate what an upstream
project might release as it’s source code to then be consumed and packaged for
distribution.

Below is an example procedure for each example implementation.

[[bello]]
=== bello

For the https://www.gnu.org/software/bash/[bash] example implementation we will have a fake project called
__bello__ and since the project named __bello__ produces one thing and that’s
a shell script named ``bello`` then it will only contain that in it’s resulting
``tar.gz``. Let’s pretend that this is version ``0.1`` of that software and
we’ll mark the ``tar.gz`` file as such.

Here is the listing of the file as mentioned before.

``bello``

[source,bash]
----
#!/bin/bash

printf "Hello World\n"

----

Let’s make a project ``tar.gz`` out of our source code.

[source,bash]
----
$ mkdir /tmp/bello-0.1

$ mv ~/bello /tmp/bello-0.1/

$ cp /tmp/LICENSE /tmp/bello-0.1/

$ cd /tmp/

$ tar -cvzf bello-0.1.tar.gz bello-0.1
bello-0.1/
bello-0.1/LICENSE
bello-0.1/bello

$ mv /tmp/bello-0.1.tar.gz ~/rpmbuild/SOURCES/

----

[[pello]]
=== pello

For the https://www.python.org/[Python] example implementation we will have a fake project called
__pello__ and since the project named __pello__ produces one thing and that’s
a small program named ``pello.py`` then it will only contain that in it’s
resulting ``tar.gz``. Let’s pretend that this is version ``0.1.1`` of this
software and we’ll mark the ``tar.gz`` file as such.

Here is the listing of the file as mentioned before.

``pello.py``

[source,python]
----
#!/usr/bin/env python

print("Hello World")

----

Let’s make a project ``tar.gz`` out of our source code.

[source,bash]
----
$ mkdir /tmp/pello-0.1.1

$ mv ~/pello.py /tmp/pello-0.1.1/

$ cp /tmp/LICENSE /tmp/pello-0.1.1/

$ cd /tmp/

$ tar -cvzf pello-0.1.1.tar.gz pello-0.1.1
pello-0.1.1/
pello-0.1.1/LICENSE
pello-0.1.1/pello.py

$ mv /tmp/pello-0.1.1.tar.gz ~/rpmbuild/SOURCES/

----

[[cello]]
=== cello

For the https://en.wikipedia.org/wiki/C_%28programming_language%29[C] example implementation we will have a fake project called __cello__
and since the project named __cello__ produces two things, the source code to our
program named ``cello.c`` and a ``Makefile`` we will need to make sure and
include both of these in our ``tar.gz``. Let’s pretend that this is version
``1.0`` of the software and we’ll mark the ``tar.gz`` file as such.

Here is the listing of the files involved as mentioned before.

You will notice the ``patch`` file is listed here, but it will not go in our
project tarball because it is something that we as the RPM Packager will apply
and not something that comes from the upstream source code. RPM Packages are
built in such a way that the original upstream source code in preserved in it’s
pristine form just as released by it’s creator. All patches required to the
software happen at RPM Build time, not before. We will place that in the
``~/rpmbuild/SOURCES/`` directory along side the “upstream” source code that we
are simulating here. (More on this later).

``cello.c``

[source,c]
----
#include <stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}

----

``cello-output-first-patch.patch``

[source,diff]
----
--- cello.c.orig        2016-05-26 17:21:30.478523360 -0500
+++ cello.c     2016-05-27 14:53:20.668588245 -0500
@@ -1,6 +1,6 @@
 #include<stdio.h>

 int main(void){
-    printf("Hello World\n");
+    printf("Hello World from my very first patch!\n");
     return 1;
 }

----

``Makefile``

[source,makefile]
----
cello:
        gcc -o cello cello.c

clean:
        rm cello

install:
        mkdir -p $(DESTDIR)/usr/bin
        install -m 0755 cello $(DESTDIR)/usr/bin/cello

----

Let’s make a project ``tar.gz`` out of our source code.

[source,bash]
----
$ mkdir /tmp/cello-1.0

$ mv ~/cello.c /tmp/cello-1.0/

$ mv ~/Makefile /tmp/cello-1.0/

$ cp /tmp/LICENSE /tmp/cello-1.0/

$ cd /tmp/

$ tar -cvzf cello-1.0.tar.gz cello-1.0
cello-1.0/
cello-1.0/Makefile
cello-1.0/cello.c
cello-1.0/LICENSE

$ mv /tmp/cello-1.0.tar.gz ~/rpmbuild/SOURCES/

$ mv ~/cello-output-first-patch.patch ~/rpmbuild/SOURCES/

----

Great, now we have all of our upstream source code prep’d and ready to be turned
into RPMs!
